// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0

package pg

import (
	"database/sql/driver"
	"fmt"
	"time"

	"github.com/google/uuid"
	"github.com/patraden/ya-practicum-gophkeeper/pkg/domain/user"
)

type RequestCommiter string

const (
	RequestCommiterUser   RequestCommiter = "user"
	RequestCommiterServer RequestCommiter = "server"
	RequestCommiterS3     RequestCommiter = "s3"
)

func (e *RequestCommiter) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = RequestCommiter(s)
	case string:
		*e = RequestCommiter(s)
	default:
		return fmt.Errorf("unsupported scan type for RequestCommiter: %T", src)
	}
	return nil
}

type NullRequestCommiter struct {
	RequestCommiter RequestCommiter
	Valid           bool // Valid is true if RequestCommiter is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullRequestCommiter) Scan(value interface{}) error {
	if value == nil {
		ns.RequestCommiter, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.RequestCommiter.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullRequestCommiter) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.RequestCommiter), nil
}

type RequestStatus string

const (
	RequestStatusCompleted RequestStatus = "completed"
	RequestStatusAborted   RequestStatus = "aborted"
	RequestStatusExpired   RequestStatus = "expired"
	RequestStatusCancelled RequestStatus = "cancelled"
)

func (e *RequestStatus) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = RequestStatus(s)
	case string:
		*e = RequestStatus(s)
	default:
		return fmt.Errorf("unsupported scan type for RequestStatus: %T", src)
	}
	return nil
}

type NullRequestStatus struct {
	RequestStatus RequestStatus
	Valid         bool // Valid is true if RequestStatus is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullRequestStatus) Scan(value interface{}) error {
	if value == nil {
		ns.RequestStatus, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.RequestStatus.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullRequestStatus) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.RequestStatus), nil
}

type RequestType string

const (
	RequestTypePut RequestType = "put"
	RequestTypeGet RequestType = "get"
)

func (e *RequestType) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = RequestType(s)
	case string:
		*e = RequestType(s)
	default:
		return fmt.Errorf("unsupported scan type for RequestType: %T", src)
	}
	return nil
}

type NullRequestType struct {
	RequestType RequestType
	Valid       bool // Valid is true if RequestType is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullRequestType) Scan(value interface{}) error {
	if value == nil {
		ns.RequestType, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.RequestType.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullRequestType) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.RequestType), nil
}

type Rek struct {
	ID        bool      `db:"id"`
	RekHash   []byte    `db:"rek_hash"`
	CreatedAt time.Time `db:"created_at"`
}

type Secret struct {
	UserID         uuid.UUID `db:"user_id"`
	SecretID       uuid.UUID `db:"secret_id"`
	SecretName     string    `db:"secret_name"`
	CurrentVersion uuid.UUID `db:"current_version"`
	CreatedAt      time.Time `db:"created_at"`
	UpdatedAt      time.Time `db:"updated_at"`
}

type SecretMetum struct {
	ID        int64     `db:"id"`
	UserID    uuid.UUID `db:"user_id"`
	SecretID  uuid.UUID `db:"secret_id"`
	Meta      []byte    `db:"meta"`
	CreatedAt time.Time `db:"created_at"`
	UpdatedAt time.Time `db:"updated_at"`
}

type SecretRequestsCompleted struct {
	ID            int64           `db:"id"`
	UserID        uuid.UUID       `db:"user_id"`
	SecretID      uuid.UUID       `db:"secret_id"`
	S3Url         string          `db:"s3_url"`
	Version       uuid.UUID       `db:"version"`
	ParentVersion uuid.UUID       `db:"parent_version"`
	RequestType   RequestType     `db:"request_type"`
	Token         int64           `db:"token"`
	ClientInfo    string          `db:"client_info"`
	SecretSize    int64           `db:"secret_size"`
	SecretHash    []byte          `db:"secret_hash"`
	SecretDek     []byte          `db:"secret_dek"`
	CreatedAt     time.Time       `db:"created_at"`
	ExpiresAt     time.Time       `db:"expires_at"`
	FinishedAt    time.Time       `db:"finished_at"`
	Status        RequestStatus   `db:"status"`
	CommitedBy    RequestCommiter `db:"commited_by"`
}

type SecretRequestsInProgress struct {
	ID            int64       `db:"id"`
	UserID        uuid.UUID   `db:"user_id"`
	SecretID      uuid.UUID   `db:"secret_id"`
	SecretName    string      `db:"secret_name"`
	S3Url         string      `db:"s3_url"`
	Version       uuid.UUID   `db:"version"`
	ParentVersion uuid.UUID   `db:"parent_version"`
	RequestType   RequestType `db:"request_type"`
	Token         int64       `db:"token"`
	ClientInfo    string      `db:"client_info"`
	SecretSize    int64       `db:"secret_size"`
	SecretHash    []byte      `db:"secret_hash"`
	SecretDek     []byte      `db:"secret_dek"`
	Meta          []byte      `db:"meta"`
	CreatedAt     time.Time   `db:"created_at"`
	ExpiresAt     time.Time   `db:"expires_at"`
}

type SecretVersion struct {
	ID            int64     `db:"id"`
	UserID        uuid.UUID `db:"user_id"`
	SecretID      uuid.UUID `db:"secret_id"`
	Version       uuid.UUID `db:"version"`
	ParentVersion uuid.UUID `db:"parent_version"`
	S3Url         string    `db:"s3_url"`
	SecretSize    int64     `db:"secret_size"`
	SecretHash    []byte    `db:"secret_hash"`
	SecretDek     []byte    `db:"secret_dek"`
	CreatedAt     time.Time `db:"created_at"`
}

type User struct {
	ID         uuid.UUID `db:"id"`
	Username   string    `db:"username"`
	Role       user.Role `db:"role"`
	CreatedAt  time.Time `db:"created_at"`
	UpdatedAt  time.Time `db:"updated_at"`
	Password   []byte    `db:"password"`
	Salt       []byte    `db:"salt"`
	Verifier   []byte    `db:"verifier"`
	BucketName string    `db:"bucket_name"`
	IdentityID string    `db:"identity_id"`
}

type UserCryptoKey struct {
	UserID    uuid.UUID `db:"user_id"`
	Kek       []byte    `db:"kek"`
	Algorithm string    `db:"algorithm"`
	CreatedAt time.Time `db:"created_at"`
	UpdatedAt time.Time `db:"updated_at"`
}

type UserIdentityToken struct {
	UserID           uuid.UUID `db:"user_id"`
	AccessToken      string    `db:"access_token"`
	RefreshToken     string    `db:"refresh_token"`
	ExpiresAt        time.Time `db:"expires_at"`
	RefreshExpiresAt time.Time `db:"refresh_expires_at"`
	CreatedAt        time.Time `db:"created_at"`
	UpdatedAt        time.Time `db:"updated_at"`
}
